!=================================================================================================================================
! Copyright (c) 2010-2024  Prof. Claus-Dieter Munz
! This file is part of FLEXI, a high-order accurate framework for numerically solving PDEs with discontinuous Galerkin methods.
! For more information see https://www.flexi-project.org and https://nrg.iag.uni-stuttgart.de/
!
! FLEXI is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
! as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
! FLEXI is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
! of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License v3.0 for more details.
!
! You should have received a copy of the GNU General Public License along with FLEXI. If not, see <http://www.gnu.org/licenses/>.
!=================================================================================================================================
#include "flexi.h"
#include "eos.h"

!==================================================================================================================================
!> Subroutines needed by the eddy viscosity model. This is the default  model, which means no eddy viscosity.
!> We need to initialize some arrays that are used in the interfaces to the rounties. The eddy viscosity model itself will
!> return 0 as turbulent viscosity.
!==================================================================================================================================
MODULE MOD_DefaultEddyVisc
! MODULES
IMPLICIT NONE
PRIVATE

PUBLIC::InitDefaultEddyVisc, DefaultEddyVisc_Volume, FinalizeDefaultEddyViscosity
!===================================================================================================================================

CONTAINS

!===================================================================================================================================
!> Initialize k-g model
!===================================================================================================================================
SUBROUTINE InitDefaultEddyVisc()
! MODULES
USE MOD_Globals
USE MOD_PreProc
USE MOD_EddyVisc_Vars
USE MOD_ReadInTools        ,ONLY: GETREAL,GETLOGICAL
USE MOD_ReadInTools        ,ONLY: CountOption,GETREALARRAY,GETSTR,GETREAL,GETLOGICAL
USE MOD_HDF5_Input         ,ONLY: ReadArray,OpenDataFile,CloseDataFile,GetDataSize,ReadAttribute
USE MOD_IO_HDF5
USE MOD_2D                 ,ONLY: ExpandArrayTo3D
USE MOD_Interpolation_Vars ,ONLY: InterpolationInitIsDone,wGP
USE MOD_Mesh_Vars          ,ONLY: MeshInitIsDone,nElems,sJ,Elem_xGP,MeshFile,offsetElem
USE MOD_EOS_Vars           ,ONLY: mu0
USE MOD_Mesh_Vars          ,ONLY: sJ,Metrics_fTilde,Metrics_gTilde,Metrics_hTilde
USE MOD_Equation_Vars      ,ONLY: alphaModelCorrection
USE MOD_Interpolation      ,ONLY: GetNodesAndWeights
USE MOD_Interpolation_Vars ,ONLY: NodeType
USE MOD_Basis              ,ONLY: PolynomialDerivativeMatrix,LagrangeInterpolationPolys,PolynomialMassMatrix
IMPLICIT NONE
!-----------------------------------------------------------------------------------------------------------------------------------
! INPUT/OUTPUT VARIABLES
!-----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
LOGICAL             :: file_exists
INTEGER             :: i,j,k,iElem
INTEGER             :: HSize_proc(4)
CHARACTER(LEN=255)  :: FileName
REAL                :: CellVol
REAL,ALLOCATABLE    :: yWall_local(:,:,:,:)
INTEGER             :: l
REAL,ALLOCATABLE    :: xRef(:), D(:,:)
!===================================================================================================================================
SWRITE(UNIT_stdOut,'(132("-"))')
SWRITE(UNIT_stdOut,'(A)') ' INIT k-g RANS...'

IF (alphaModelCorrection) THEN
  ALLOCATE(xRef(0:PP_N))
  ALLOCATE(D(0:PP_N,0:PP_N))

  CALL GetNodesAndWeights(PP_N,NodeType,xRef)
  CALL PolynomialDerivativeMatrix(PP_N,xRef,D)

  ! allocate memory
  ALLOCATE(yWall(0:PP_N,0:PP_N,0:PP_NZ,0:FV_SIZE,nElems))
  ALLOCATE(gradyWall(3,0:PP_N,0:PP_N,0:PP_NZ,0:FV_SIZE,nElems))

  ! Read in a file that contains the distance to the nearest wall for each solution point (generated by POSTI tool).
  yWall = SQRT(HUGE(1.))
  FileName = MeshFile(1:INDEX(MeshFile,'_mesh.h5')-1)//'_walldistance.h5'
  file_exists = FILEEXISTS(FileName)
  IF (file_exists) THEN
    CALL OpenDataFile(TRIM(FileName),create=.FALSE.,single=.FALSE.,readOnly=.TRUE.)
    CALL GetDataSize(File_ID,'walldistance',nDims,HSize)
    IF (HSize(1)-1.NE.PP_N) CALL Abort(__STAMP__,"Polynomial degree of walldistance file does not match!")
    ALLOCATE(yWall_local(0:HSize(1)-1,0:HSize(2)-1,0:HSize(3)-1,nElems))
    HSize_proc = INT(HSize)
    HSize_proc(4) = nElems
    CALL ReadArray('walldistance',4,&
                    HSize_proc,&
                    offsetElem,4,RealArray=yWall_local)

    IF (HSize(3).EQ.1) THEN
      ! Walldistance was created by 2D tool, expand in third dimension
      CALL ExpandArrayTo3D(4,(/PP_N+1,PP_N+1,1,nElems/),3,PP_N+1,yWall_local,yWall(:,:,:,0,:))
    ELSE
      ! 3D walldistance tool and 3D Flexi
      yWall(:,:,:,0,:) = yWall_local
    END IF

    DEALLOCATE(HSize)
    DEALLOCATE(yWall_local)
    CALL CloseDataFile()

    gradyWall = 0.0
    DO iElem=1,nElems
      DO k=0,PP_NZ; DO j=0,PP_N; DO i=0,PP_N
        DO l=0,PP_N
          gradyWall(1,i,j,k,0,iElem) = gradyWall(1,i,j,k,0,iElem) + D(i,l) * ywall(l,j,k,0,iElem)
          gradyWall(2,i,j,k,0,iElem) = gradyWall(2,i,j,k,0,iElem) + D(j,l) * ywall(i,l,k,0,iElem)
#if PP_dim==3
          gradyWall(3,i,j,k,0,iElem) = gradyWall(3,i,j,k,0,iElem) + D(k,l) * ywall(i,j,l,0,iElem)
#endif
        END DO
        gradyWall(:,i,j,k,0,iElem) = ( &
          gradyWall(1,i,j,k,0,iElem) * Metrics_fTilde(:,i,j,k,iElem,0) + &
          gradyWall(2,i,j,k,0,iElem) * Metrics_gTilde(:,i,j,k,iElem,0) &
#if PP_dim==3
        + gradyWall(3,i,j,k,0,iElem) * Metrics_hTilde(:,i,j,k,iElem,0) &
#endif
        ) * sJ(i,j,k,iElem,0)
      END DO; END DO; END DO
    END DO
  ELSE
    SWRITE(UNIT_stdOut, *) "WARNING: No walldistance file found! alpha model not working!"
    CALL CollectiveStop(__STAMP__,'Please use POSTI to compute wall distance first!')
  ENDIF
END IF

SWRITE(UNIT_stdOut,'(A)')' INIT k-g RANS DONE!'
SWRITE(UNIT_stdOut,'(132("-"))')
END SUBROUTINE InitDefaultEddyVisc

!===================================================================================================================================
!> Compute k-g Eddy-Visosity
!===================================================================================================================================
PPURE SUBROUTINE DefaultEddyVisc_Point(gradUx,gradUy,gradUz,U,muSGS)
! MODULES
USE MOD_Equation_Vars ,ONLY: Cmu,sqrt6
IMPLICIT NONE
!-----------------------------------------------------------------------------------------------------------------------------------
! INPUT/OUTPUT VARIABLES
REAL,DIMENSION(PP_nVarLifting),INTENT(IN)  :: gradUx, gradUy, gradUz   !> Gradients in x,y,z directions
REAL,DIMENSION(PP_nVar)       ,INTENT(IN)  :: U       !> pointwise conservative vairables
REAL                          ,INTENT(OUT) :: muSGS   !> pointwise eddyviscosity
!-----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
REAL                                    :: magS
REAL                                    :: kPos,gPos,muTOrig
!===================================================================================================================================
! Already take the square root of 2 into account here
#if PP_dim==2
magS = SQRT( &
    2. * (gradUx(LIFT_VEL1)**2 + gradUy(LIFT_VEL2)**2) + &
    (gradUy(LIFT_VEL1) + gradUx(LIFT_VEL2))**2)
#else
magS = SQRT( &
    2. * (gradUx(LIFT_VEL1)**2 + gradUy(LIFT_VEL2)**2 + gradUz(LIFT_VEL3)**2) + &
    (gradUy(LIFT_VEL1) + gradUx(LIFT_VEL2))**2 + &
    (gradUz(LIFT_VEL1) + gradUx(LIFT_VEL3))**2 + &
    (gradUz(LIFT_VEL2) + gradUy(LIFT_VEL3))**2)
#endif

kPos    = MAX( U(RHOK) / U(DENS), 1.e-16 )
gPos    = MAX( U(RHOG) / U(DENS), 1.e-16 )
muTOrig = Cmu * U(DENS) * kPos * gPos**2

muSGS = MIN(muTOrig,  U(DENS) * kPos / MAX(sqrt6 * magS, 1.e-16))
END SUBROUTINE DefaultEddyVisc_Point

!===================================================================================================================================
!> Compute k-g Eddy-Visosity for the volume
!===================================================================================================================================
SUBROUTINE DefaultEddyVisc_Volume()
! MODULES
USE MOD_PreProc
USE MOD_Mesh_Vars,         ONLY: nElems
USE MOD_EddyVisc_Vars,     ONLY: muSGS
USE MOD_Lifting_Vars,      ONLY: gradUx, gradUy, gradUz
USE MOD_DG_Vars,           ONLY: U
IMPLICIT NONE
!-----------------------------------------------------------------------------------------------------------------------------------
! INPUT/OUTPUT VARIABLES
!-----------------------------------------------------------------------------------------------------------------------------------
! LOCAL VARIABLES
INTEGER             :: i,j,k,iElem
!===================================================================================================================================
DO iElem=1,nElems
  DO k=0,PP_NZ; DO j=0,PP_N; DO i=0,PP_N
    CALL DefaultEddyVisc_Point(gradUx(:,i,j,k,iElem), gradUy(:,i,j,k,iElem), gradUz(:,i,j,k,iElem), &
                               U(:,i,j,k,iElem),      muSGS(1,i,j,k,iElem))
  END DO; END DO; END DO ! i,j,k
END DO
END SUBROUTINE DefaultEddyVisc_Volume

!===============================================================================================================================
!> Deallocate arrays and finalize variables used by the default eddy viscosity
!===============================================================================================================================
SUBROUTINE FinalizeDefaultEddyviscosity()
! MODULES
IMPLICIT NONE
!===============================================================================================================================
END SUBROUTINE FinalizeDefaultEddyViscosity

END MODULE MOD_DefaultEddyVisc
